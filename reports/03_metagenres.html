<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Markus Radke">
<meta name="dcterms.date" content="2025-10-31">

<title>Metagenres - Genre Discourse Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="03_metagenres_files/libs/clipboard/clipboard.min.js"></script>
<script src="03_metagenres_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="03_metagenres_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="03_metagenres_files/libs/quarto-html/popper.min.js"></script>
<script src="03_metagenres_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03_metagenres_files/libs/quarto-html/anchor.min.js"></script>
<link href="03_metagenres_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03_metagenres_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03_metagenres_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03_metagenres_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03_metagenres_files/libs/bootstrap/bootstrap-813c323200a87c37e262811031999de4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="03_metagenres_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="03_metagenres_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="03_metagenres_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">
<script src="03_metagenres_files/libs/htmlwidgets-1.6.4/htmlwidgets.js"></script>

<script src="03_metagenres_files/libs/r2d3-render-0.1.0/r2d3-render.js"></script>

<script src="03_metagenres_files/libs/webcomponents-2.0.0/webcomponents.js"></script>

<script src="03_metagenres_files/libs/r2d3-binding-0.2.6/r2d3.js"></script>

<script src="03_metagenres_files/libs/d3v6-6.2.0/d3.min.js"></script>



<link rel="stylesheet" href="styles.css">
</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="5">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#algorithm-for-folding-the-genre-tree-to-get-metagenres" id="toc-algorithm-for-folding-the-genre-tree-to-get-metagenres" class="nav-link active" data-scroll-target="#algorithm-for-folding-the-genre-tree-to-get-metagenres"><span class="header-section-number">1</span> Algorithm for folding the genre tree to get metagenres</a></li>
  <li><a href="#tuning-results-and-suggested-solutions" id="toc-tuning-results-and-suggested-solutions" class="nav-link" data-scroll-target="#tuning-results-and-suggested-solutions"><span class="header-section-number">2</span> Tuning results and suggested solutions</a>
  <ul>
  <li><a href="#musicbrainz-metagenres" id="toc-musicbrainz-metagenres" class="nav-link" data-scroll-target="#musicbrainz-metagenres"><span class="header-section-number">2.1</span> MusicBrainz Metagenres</a></li>
  <li><a href="#spotify-metagenres" id="toc-spotify-metagenres" class="nav-link" data-scroll-target="#spotify-metagenres"><span class="header-section-number">2.2</span> Spotify Metagenres</a></li>
  </ul></li>
  </ul>
<div class="quarto-code-links"><h2>Code Links</h2><ul><li><a href="https://github.com/markusradke/GenreDiscourseAnalysis"><i class="bi bi-link-45deg"></i>Github Repository</a></li></ul></div></nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Metagenres - Genre Discourse Analysis</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Markus Radke </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 31, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="algorithm-for-folding-the-genre-tree-to-get-metagenres" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Algorithm for folding the genre tree to get metagenres</h1>
<!-- TODO: Add a little explanation on the algorithm (see Bayreuth slides) -->
<p>Root of the tree is “other” genre. This is why it does not need to fulfill the minimum song count requirement.</p>
<p>We need to ensure that when merging genres, we merge all siblings and all grandchildren of the parent genre to avoid dangling nodes in the tree. Due to how the trees are created, merging grand children that already fulfilled the min n requirement will not occur often (genres that are closer to the root are expected to appear more frequent in initial genres than genres further away from the root).</p>
<p>The algorithm works as follows:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">%%{init: {
  'flowchart': {
    'nodeSpacing': 50, 
    'rankSpacing': 80,
    'useMaxWidth': true,
    'htmlLabels': false,
    'curve': 'basis'
  }, 
  'theme': 'base',
  'themeVariables': {
    'fontSize': '22px',
    'fontFamily': 'Arial, sans-serif',
    'primaryColor': '#ffffff',
    'primaryTextColor': '#333333',
    'primaryBorderColor': '#cccccc', 
    'lineColor': '#666666',
    'textColor': '#333333'
  }
}}%%
flowchart TD
    A["Start with initial music genres and hierarchy tree"] --&gt; B["Try different minimum song counts (grid search)"]
    B --&gt; C["For each minimum count: Start folding process"]
    C --&gt; D["Find leaf genre with most songs at deepest level"]
    D --&gt; E{"Does this genre have enough songs?"}
    E --&gt;|Yes| F{"Is the parent genre the root of the tree?"}
    E --&gt;|No| G["Merge genre with parent and all siblings and all grandchildren of parent that were already metagenres"]
    F --&gt;|No| FF{"Would parent + siblings have enough songs combined?"}
    FF --&gt; |Yes| H["Pluck genre from tree (cut connection to parent)"]
    FF --&gt;|No| G
    F --&gt;|Yes| H
    G --&gt; I["Update song counts and mark genres as processed"]
    H --&gt; I
    I --&gt; J{"Are we at the root level?"}
    J --&gt;|No| D
    J --&gt;|Yes| K["Calculate diversity score (Gini coefficient)"]
    K --&gt; L{"Can we calculate a valid diversity score?"}
    L --&gt;|Yes| M["Save this solution and try next minimum count"]
    L --&gt;|No| N["Stop search - no more valid solutions"]
    M --&gt; O{"More minimum counts to try?"}
    O --&gt;|Yes| C
    O --&gt;|No| P["Remove duplicate solutions and return best options"]
    N --&gt; P
    P --&gt; Q["End: Return optimized genre groupings"]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="tuning-results-and-suggested-solutions" class="level1 page-columns page-full" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Tuning results and suggested solutions</h1>
<div class="cell">
<details class="code-fold">
<summary>Show/Hide Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>mb <span class="ot">&lt;-</span> <span class="fu">read_feather_with_lists</span>(<span class="st">"../data/filtered_mb_long.feather"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>mb_tuning_metadata <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/tune_mb_metadata.rds"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>mb_gini_plot <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/tune_mb_gini_plot.rds"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>mb_suggested_solution <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/metagenres_mb_suggested_solution.rds"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>s <span class="ot">&lt;-</span> <span class="fu">read_feather_with_lists</span>(<span class="st">"../data/filtered_s_long.feather"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>s_tuning_metadata <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/tune_s_metadata.rds"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>s_gini_plot <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/tune_s_gini_plot.rds"</span>)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>s_suggested_solution <span class="ot">&lt;-</span> <span class="fu">readRDS</span>(<span class="st">"../models/metagenres/metagenres_s_suggested_solution.rds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="musicbrainz-metagenres" class="level2 page-columns page-full" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="musicbrainz-metagenres"><span class="header-section-number">2.1</span> MusicBrainz Metagenres</h2>
<details class="code-fold">
<summary>Show/Hide Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>mb_gini_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-musicbrainz-gini" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-musicbrainz-gini-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03_metagenres_files/figure-html/gini_plot_musicbrainz-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-musicbrainz-gini-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the MusicBrainz genre tree. Calculated for a minimum n tracks per genre of 1,000 to 4,980. Resulting number of metagenres ranged from 10 to 42.
</figcaption>
</figure>
</div>
<div class="column-screen-inset-right">
<div class="plot-container">
<div class="cell">
<details class="code-fold">
<summary>Show/Hide Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>mb_long_metagenres <span class="ot">&lt;-</span> mb <span class="sc">%&gt;%</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">left_join</span>(mb_suggested_solution<span class="sc">$</span>mapping, <span class="at">by =</span> <span class="st">"tag_name"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>tag_name) <span class="sc">%&gt;%</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">rename</span>(<span class="at">tag_name =</span> metagenre)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_network_graph</span>(<span class="at">graph =</span> mb_suggested_solution<span class="sc">$</span>metagenre_graph, </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">get_sizes_lookup</span>(mb_long_metagenres, <span class="at">root =</span> <span class="st">"POPULAR MUSIC"</span>),</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">get_fills_lookup</span>(mb_long_metagenres, <span class="at">root =</span> <span class="st">"POPULAR MUSIC"</span>),</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                   <span class="at">height =</span> <span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="htmlwidget-dd90090e1e8fe8281a59" style="width:100%;height:1000px;" class="r2d3 html-widget"></div>
<script type="application/json" data-for="htmlwidget-dd90090e1e8fe8281a59">{"x":{"data":{"tree":{"name":"POPULAR MUSIC","size":0.001,"fill":"#000000ff","children":[{"name":"rock","size":38715.70171434546,"fill":"#808080ff","children":[{"name":"alternative rock","size":6781.427134791829,"fill":"#808080ff"},{"name":"blues","size":1601.116266551886,"fill":"#808080ff"},{"name":"blues rock","size":1798.095064052215,"fill":"#808080ff"},{"name":"classic rock","size":1769.750290337726,"fill":"#808080ff"},{"name":"country","size":1920.156308224493,"fill":"#808080ff"},{"name":"folk","size":2476.557485742449,"fill":"#808080ff"},{"name":"folk rock","size":1971.114282563218,"fill":"#808080ff"},{"name":"hard rock","size":4820.285229127846,"fill":"#808080ff"},{"name":"heavy metal","size":5331.461669157132,"fill":"#808080ff","children":[{"name":"power metal","size":1894.201604158369,"fill":"#808080ff"}]},{"name":"indie rock","size":4009.881231889484,"fill":"#808080ff"},{"name":"metal","size":12776.07969116277,"fill":"#808080ff","children":[{"name":"death metal","size":1715.732290082613,"fill":"#808080ff"}]},{"name":"pop","size":37076.84098777182,"fill":"#808080ff","children":[{"name":"classical","size":2662.61996896637,"fill":"#808080ff"},{"name":"electronic","size":18389.17603572944,"fill":"#808080ff","children":[{"name":"house","size":1521.061425081304,"fill":"#808080ff"}]},{"name":"hip hop","size":26244.27940068663,"fill":"#808080ff"},{"name":"jazz","size":5887.5190020134,"fill":"#808080ff"},{"name":"r&b","size":1888.861667143211,"fill":"#808080ff"},{"name":"reggae","size":1588.368710406872,"fill":"#808080ff"},{"name":"schlager","size":7416.749722910626,"fill":"#808080ff"},{"name":"soul","size":2958.425789978221,"fill":"#808080ff"},{"name":"synth-pop","size":1940.049645029703,"fill":"#808080ff"}]},{"name":"pop rock","size":5112.093715729796,"fill":"#808080ff"},{"name":"progressive rock","size":2465.57068023608,"fill":"#808080ff"},{"name":"punk","size":3475.708920882621,"fill":"#808080ff"},{"name":"singer-songwriter","size":1976.114065246421,"fill":"#808080ff"}]}]},"weights":{"key":["alternative rock->rock","blues->rock","blues rock->rock","classic rock->rock","classical->pop","country->rock","death metal->metal","electronic->pop","folk->rock","folk rock->rock","hard rock->rock","heavy metal->rock","hip hop->pop","house->electronic","indie rock->rock","jazz->pop","metal->rock","pop->rock","pop rock->rock","power metal->heavy metal","progressive rock->rock","punk->rock","r&b->pop","reggae->pop","rock->POPULAR MUSIC","schlager->pop","singer-songwriter->rock","soul->pop","synth-pop->pop"],"weight":[0.5556484541072864,0.6202446735444169,0.7536454953430334,0.8212867036716518,0.2503342476087773,0.3728958436076848,0.5711489549041839,0.2355391975115447,0.4681675577827863,0.6835209335993552,0.6105661311447128,0.5195488599614297,0.0613673778388014,0.5862531041253622,0.5935162931143938,0.2484822610099942,0.4931470782897256,0.08816566024446482,0.5340852338368983,0.4980738483109783,0.6833578522625122,0.6563786288617565,0.5089817225981107,0.2912867392177138,0,0.2875451829711562,0.5862580820110836,0.4803813382902066,0.5439906025750842]},"margin_left":150,"margin_right":350,"margin_top":0,"margin_bottom":0,"min_font_size":22,"max_font_size":36},"type":"list","container":"svg","options":{"container":"div","viewer":null},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  N:/Materialien/Promotion/GenreDiscourseAnalysis/inst/d3/interactive_network_plot.js */\n// Interactive Network Plot - Fully responsive dimensions\nconst minNodeSpacing = 30; // Minimum spacing between nodes to prevent overlap\n\n// Get responsive width from container with timing-safe approach\nconst getResponsiveWidth = () => {\n    // Try multiple ways to get the container width\n    const svgNode = svg.node();\n    const computedStyle = window.getComputedStyle(svgNode);\n    if (computedStyle.width && computedStyle.width !== \"auto\") {\n        const width = parseFloat(computedStyle.width);\n        if (width > 0) {\n            return width - 4;\n        }\n    }\n\n    // Fallback to viewport width\n    console.log(\"Using viewport fallback width\");\n    return window.innerWidth * 0.8;\n};\n\n// Use responsive dimensions - prioritize container dimensions over r2d3 data\nconst actualHeight = (data.height || 1000) - 4; // Reduce by 4px for borders/padding\nconst actualWidth = getResponsiveWidth();\n\n// Calculate dynamic height based on tree structure\nfunction calculateRequiredHeight(root) {\n    const visibleNodes = root.descendants();\n    const nodesByDepth = {};\n\n    // Group nodes by depth level\n    visibleNodes.forEach(node => {\n        const depth = node.depth;\n        if (!nodesByDepth[depth]) {\n            nodesByDepth[depth] = [];\n        }\n        nodesByDepth[depth].push(node);\n    });\n\n    // Find the depth level with the most nodes\n    const maxNodesAtLevel = Math.max(...Object.values(nodesByDepth).map(nodes => nodes.length));\n\n    // Calculate required height: nodes * spacing (no margins needed with pan/zoom)\n    const requiredHeight = Math.max(\n        600, // Minimum height\n        maxNodesAtLevel * minNodeSpacing\n    );\n\n    return requiredHeight;\n}\n\n// Initialize with container height, will be recalculated for tree layout\nlet currentHeight = actualHeight;\n\n// Set up the SVG to exactly match the container (no manual sizing)\nsvg.attr(\"width\", actualWidth)\n    .attr(\"height\", actualHeight)\n    .style(\"background-color\", \"#fafafa\")\n    .style(\"overflow\", \"hidden\") // Remove scrollbars\n    .style(\"cursor\", \"grab\")\n    .style(\"display\", \"block\");\n\n// Add resize handler for responsive width\nwindow.addEventListener(\"resize\", function() {\n    const newWidth = getResponsiveWidth();\n    svg.attr(\"width\", newWidth);\n\n    // If there\"s tree content, we might want to recalculate layout\n    // For now, just update the SVG width - the pan/zoom will handle positioning\n});\n\n// Add zoom behavior\nconst zoom = d3.zoom()\n    .scaleExtent([0.1, 3]) // Zoom limits\n    .on(\"zoom\", (event) => {\n        container.attr(\"transform\", event.transform);\n        // Update cursor during pan\n        svg.style(\"cursor\", event.sourceEvent && event.sourceEvent.type === \"mousemove\" ? \"grabbing\" : \"grab\");\n    });\n\nsvg.call(zoom);\n\n// Create container for tree (this will be transformed by zoom/pan)\nconst container = svg.append(\"g\")\n    .attr(\"class\", \"tree-container\");\n\n// Add center button\nconst centerButton = svg.append(\"g\")\n    .attr(\"class\", \"center-button\")\n    .attr(\"transform\", \"translate(20, 20)\")\n    .style(\"cursor\", \"pointer\");\n\n// Button background\ncenterButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#007acc\")\n    .style(\"stroke\", \"#005a9e\")\n    .style(\"stroke-width\", 1);\n\n// Button text\ncenterButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Center root\");\n\n// Button click handler\ncenterButton.on(\"click\", function() {\n    centerOnRoot();\n});\n\n// Add \"Expand All\" button\nconst expandAllButton = svg.append(\"g\")\n    .attr(\"class\", \"expand-all-button\")\n    .attr(\"transform\", \"translate(20, 60)\") // Position below center button\n    .style(\"cursor\", \"pointer\");\n\n// Expand All button background\nexpandAllButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#28a745\")\n    .style(\"stroke\", \"#1e7e34\")\n    .style(\"stroke-width\", 1);\n\n// Expand All button text\nexpandAllButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Expand All\");\n\n// Expand All button click handler\nexpandAllButton.on(\"click\", function() {\n    expandAll();\n});\n\n// Add \"Fold All\" button\nconst foldAllButton = svg.append(\"g\")\n    .attr(\"class\", \"fold-all-button\")\n    .attr(\"transform\", \"translate(20, 100)\") // Position below expand button\n    .style(\"cursor\", \"pointer\");\n\n// Fold All button background\nfoldAllButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#dc3545\")\n    .style(\"stroke\", \"#c82333\")\n    .style(\"stroke-width\", 1);\n\n// Fold All button text\nfoldAllButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Fold All\");\n\n// Fold All button click handler\nfoldAllButton.on(\"click\", function() {\n    foldAll();\n});\n\n// Function to center the view on the root node\nfunction centerOnRoot() {\n    if (!hierarchyRoot) return;\n\n    // Find the actual root node position after tree layout\n    const rootNode = hierarchyRoot;\n    const rootX = rootNode.x || 0;\n    const rootY = rootNode.y || 0;\n\n    // Calculate transform to center the root in the actual viewport\n    const centerX = actualWidth / 2;\n    const centerY = actualHeight / 2; // Center in actual viewport\n\n    const transform = d3.zoomIdentity\n        .translate(centerX - rootY, centerY - rootX) // Note: x and y are swapped in horizontal tree\n        .scale(1); // Reset zoom to 1x\n\n    // Animate to center\n    svg.transition()\n        .duration(750)\n        .call(zoom.transform, transform);\n} // Copy data and create persistent hierarchy\nlet currentData = JSON.parse(JSON.stringify(data.tree));\nlet hierarchyRoot = null; // Keep the hierarchy root persistent\nlet isFirstRender = true; // Track if this is the first render\n\n// Collapse function for raw data (not used anymore but keeping for reference)\nfunction collapseToFirstLevel(node, depth = 0) {\n    if (depth >= 1 && node.children) {\n        node._children = node.children;\n        node.children = null;\n    }\n    if (node.children) {\n        node.children.forEach(child => collapseToFirstLevel(child, depth + 1));\n    }\n}\n\n// Collapse function for D3 hierarchy nodes (the one we actually use)\nfunction collapseHierarchyToFirstLevel(node, depth = 0) {\n\n    if (depth >= 1 && node.children) {\n        node._children = node.children;\n        node.children = null;\n    }\n\n    // Continue recursively for visible children\n    if (node.children) {\n        node.children.forEach(child => collapseHierarchyToFirstLevel(child, depth + 1));\n    }\n\n    // Also process hidden children to ensure deep collapse\n    if (node._children) {\n        node._children.forEach(child => collapseHierarchyToFirstLevel(child, depth + 1));\n    }\n}\n\n// Sort children by accumulated size (largest first)\nfunction sortChildrenBySize(node) {\n    // Sort visible children\n    if (node.children) {\n        node.children.sort((a, b) => calculateTotalSize(b) - calculateTotalSize(a));\n        // Recursively sort their children too\n        node.children.forEach(child => sortChildrenBySize(child));\n    }\n\n    // Sort hidden children (so they\"re in the right order when expanded)\n    if (node._children) {\n        node._children.sort((a, b) => calculateTotalSize(b) - calculateTotalSize(a));\n        // Recursively sort their children too\n        node._children.forEach(child => sortChildrenBySize(child));\n    }\n}\n\n// Find a node in the hierarchy by name\nfunction findNodeByName(root, name) {\n    if (root.data.name === name) {\n        return root;\n    }\n    if (root.children) {\n        for (let child of root.children) {\n            const found = findNodeByName(child, name);\n            if (found) return found;\n        }\n    }\n    if (root._children) {\n        for (let child of root._children) {\n            const found = findNodeByName(child, name);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\n// Check if a node has expandable children in persistent hierarchy\nfunction hasExpandableChildren(nodeName) {\n    if (!nodeName || !hierarchyRoot) {\n        console.warn(\"hasExpandableChildren: Invalid parameters\", {\n            nodeName,\n            hierarchyRoot: !!hierarchyRoot\n        });\n        return false;\n    }\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n    return persistentNode && (persistentNode.children || persistentNode._children);\n}\n\n// Check if a node is collapsed in persistent hierarchy\nfunction isCollapsed(nodeName) {\n    if (!nodeName || !hierarchyRoot) {\n        console.warn(\"isCollapsed: Invalid parameters\", {\n            nodeName,\n            hierarchyRoot: !!hierarchyRoot\n        });\n        return false;\n    }\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n    return persistentNode && persistentNode._children && !persistentNode.children;\n}\n\n// Calculate the total size of a node including all its descendants\nfunction calculateTotalSize(node) {\n    let totalSize = node.data.size || 0;\n\n    // Add sizes from visible children\n    if (node.children) {\n        for (let child of node.children) {\n            totalSize += calculateTotalSize(child);\n        }\n    }\n\n    // Add sizes from hidden children (collapsed nodes)\n    if (node._children) {\n        for (let child of node._children) {\n            totalSize += calculateTotalSize(child);\n        }\n    }\n\n    return totalSize;\n}\n\n// Get the effective size for display (aggregated size for collapsed nodes)\nfunction getEffectiveSize(displayNode, nodeName) {\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n\n    if (persistentNode && isCollapsed(nodeName)) {\n        // For collapsed nodes, return the total aggregated size\n        return calculateTotalSize(persistentNode);\n    } else {\n        // For expanded nodes or leaf nodes, return their own size\n        return displayNode.data.size || 0;\n    }\n}\n\n// Toggle function\nfunction toggle(d) {\n    // Safety check for data structure\n    if (!d.data) {\n        console.error(\"Node data is undefined, skipping toggle\");\n        return;\n    }\n    // Find the corresponding node in our persistent hierarchy\n    const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n    if (!persistentNode) {\n        console.error(\"Could not find node in persistent hierarchy:\", d.data.name);\n        return;\n    }\n\n    if (persistentNode.children) {\n        persistentNode._children = persistentNode.children;\n        persistentNode.children = null;\n    } else if (persistentNode._children) {\n        persistentNode.children = persistentNode._children;\n        persistentNode._children = null;\n    }\n\n    // Re-sort the entire hierarchy to maintain size-based ordering\n    sortChildrenBySize(hierarchyRoot);\n\n    update();\n}\n\n// Expand All function\nfunction expandAll() {\n    if (!hierarchyRoot) return;\n\n    // Recursively expand all nodes\n    function expandAllNodes(node) {\n        if (node._children) {\n            node.children = node._children;\n            node._children = null;\n        }\n        if (node.children) {\n            node.children.forEach(child => expandAllNodes(child));\n        }\n    }\n\n    expandAllNodes(hierarchyRoot);\n    sortChildrenBySize(hierarchyRoot);\n    update();\n\n    // Center on root and zoom out 30%\n    setTimeout(() => {\n        if (!hierarchyRoot) return;\n\n        const rootNode = hierarchyRoot;\n        const rootX = rootNode.x || 0;\n        const rootY = rootNode.y || 0;\n\n        const centerX = actualWidth / 2;\n        const centerY = actualHeight / 2;\n\n        const transform = d3.zoomIdentity\n            .translate(centerX - rootY, centerY - rootX)\n            .scale(0.7); // Zoom out 30% (100% - 30% = 70%)\n\n        svg.transition()\n            .duration(750)\n            .call(zoom.transform, transform);\n    }, 100); // Small delay to let the tree update first\n}\n\n// Fold All function\nfunction foldAll() {\n    if (!hierarchyRoot) return;\n\n    // Collapse everything to root only (no children visible)\n    function collapseToRoot(node) {\n        if (node.children) {\n            node._children = node.children;\n            node.children = null;\n        }\n        if (node._children) {\n            node._children.forEach(child => collapseToRoot(child));\n        }\n    }\n\n    collapseToRoot(hierarchyRoot);\n    sortChildrenBySize(hierarchyRoot);\n    update();\n\n    // Center on root with normal zoom (same as center button)\n    setTimeout(() => {\n        centerOnRoot();\n    }, 100); // Small delay to let the tree update first\n}\n\n// Update function\nfunction update() {\n    // Clear previous content (but keep the center button)\n    container.selectAll(\"*\").remove();\n\n    // Create or use existing hierarchy\n    if (isFirstRender) {\n        hierarchyRoot = d3.hierarchy(currentData);\n        collapseHierarchyToFirstLevel(hierarchyRoot, 0);\n        // Sort all nodes by accumulated size after initial setup\n        sortChildrenBySize(hierarchyRoot);\n        isFirstRender = false;\n    }\n\n    const root = hierarchyRoot;\n\n    // Calculate required height dynamically for tree layout\n    currentHeight = calculateRequiredHeight(root);\n\n    // Set up tree layout with full available space (no margins)\n    const treeLayout = d3.tree().size([currentHeight, actualWidth]);\n    treeLayout(root);\n\n    // Position the tree centered in the actual viewport\n    const startX = 0; // No left margin needed\n    const startY = actualHeight / 2; // Center in actual viewport\n\n    // Adjust all node positions\n    root.descendants().forEach(d => {\n        d.x = d.x - currentHeight / 2 + startY; // Center in actual viewport\n        d.y = d.y + startX; // Start from left edge\n    });\n\n    // Scale for node sizes - now considering aggregated sizes for collapsed nodes\n    const allEffectiveSizes = root.descendants().map(d => getEffectiveSize(d, d.data.name));\n    const sizeScale = d3.scaleLinear()\n        .domain([0, d3.max(allEffectiveSizes) || 1])\n        .range([4, 15]);\n\n    // Convert weights data frame to lookup object\n    const weightsLookup = {};\n    if (data.weights && Array.isArray(data.weights.key)) {\n        // R data frame comes as arrays of columns\n        for (let i = 0; i < data.weights.key.length; i++) {\n            weightsLookup[data.weights.key[i]] = data.weights.weight[i];\n        }\n    }\n\n    // Function to get edge weight from lookup\n    function getEdgeWeight(link) {\n        if (Object.keys(weightsLookup).length === 0) {\n            return null;\n        }\n        // In your graph: edges go child->parent\n        // In D3 tree: link.target = child, link.source = parent\n        // So: target->source = child->parent\n        const key = link.target.data.name + \"->\" + link.source.data.name;\n        return weightsLookup[key] || null;\n    }\n    \n    // Create scales for edge styling based on weights\n    const allWeights = root.links()\n        .map(link => getEdgeWeight(link))\n        .filter(w => w !== null);\n    \n    let strokeWidthScale, strokeColorScale;\n    if (allWeights.length > 0) {\n        const minWeight = d3.min(allWeights);\n        const maxWeight = d3.max(allWeights);\n        \n        // Stroke width: thin (0.5) for small weights, thick (4) for large weights\n        strokeWidthScale = d3.scaleLinear()\n            .domain([minWeight, maxWeight])\n            .range([0.5, 4]);\n        \n        // Stroke color: light gray for small weights, black for large weights\n        strokeColorScale = d3.scaleLinear()\n            .domain([minWeight, maxWeight])\n            .range([\"#e0e0e0\", \"#000000\"]);\n    }\n\n    // Create links\n    const links = container.selectAll(\".link\")\n        .data(root.links())\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", \"link\")\n        .attr(\"d\", d3.linkHorizontal()\n            .x(d => d.y)\n            .y(d => d.x))\n        .style(\"fill\", \"none\")\n        .style(\"stroke\", d => {\n            const weight = getEdgeWeight(d);\n            return (weight !== null && strokeColorScale) ? strokeColorScale(weight) : \"#ccc\";\n        })\n        .style(\"stroke-width\", d => {\n            const weight = getEdgeWeight(d);\n            return (weight !== null && strokeWidthScale) ? strokeWidthScale(weight) : 2;\n        });\n\n    // Add tooltips to links\n    links.append(\"title\")\n        .text(d => {\n            const weight = getEdgeWeight(d);\n            if (weight !== null) {\n                return `${d.target.data.name} → ${d.source.data.name}\\nWeight: ${weight.toFixed(4)}`;\n            }\n            return `${d.target.data.name} → ${d.source.data.name}`;\n        });\n\n    // Create node groups\n    const nodes = container.selectAll(\".node\")\n        .data(root.descendants())\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"node\")\n        .attr(\"transform\", d => `translate(${d.y}, ${d.x})`)\n        .style(\"cursor\", d => (d.data && hasExpandableChildren(d.data.name)) ? \"pointer\" : \"default\");\n\n    // Add circles\n    nodes.append(\"circle\")\n        .attr(\"r\", d => sizeScale(getEffectiveSize(d, d.data.name)))\n        .style(\"fill\", d => d.data.fill || \"#69b3a2\")\n        .style(\"stroke\", d => (d.data && hasExpandableChildren(d.data.name)) ? \"#000\" : \"none\")\n        .style(\"stroke-width\", d => (d.data && hasExpandableChildren(d.data.name)) ? 2 : 1)\n        .on(\"click\", function(event, d) {\n            // Prevent zoom behavior when clicking on nodes\n            event.stopPropagation();\n\n            // Check persistent hierarchy instead of display node\n            const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n            if (persistentNode) {\n                if (persistentNode._children || persistentNode.children) {\n                    toggle(d);\n                }\n            }\n        })\n        .on(\"mouseover\", function(event, d) {\n            if (d.data && hasExpandableChildren(d.data.name)) {\n                d3.select(this).style(\"stroke-width\", 4);\n            }\n        })\n        .on(\"mouseout\", function(event, d) {\n            d3.select(this).style(\"stroke-width\", (d.data && hasExpandableChildren(d.data.name)) ? 2 : 1);\n        });\n\n    // Add +/- indicators\n    nodes.filter(d => d.data && hasExpandableChildren(d.data.name))\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dy\", 4)\n        .style(\"font-size\", \"10px\")\n        .style(\"font-weight\", \"bold\")\n        .style(\"fill\", \"white\")\n        .style(\"pointer-events\", \"none\")\n        .text(d => isCollapsed(d.data.name) ? \"+\" : \"−\");\n\n    // Add labels\n    nodes.append(\"text\")\n        .attr(\"dy\", 3)\n        .attr(\"x\", d => hasExpandableChildren(d.data.name) ? -18 : 18)\n        .style(\"text-anchor\", d => hasExpandableChildren(d.data.name) ? \"end\" : \"start\")\n        .style(\"font-size\", \"12pt\")\n        .style(\"font-weight\", d => hasExpandableChildren(d.data.name) ? \"bold\" : \"normal\")\n        .style(\"text-decoration\", d => hasExpandableChildren(d.data.name) ? \"underline\" : \"none\")\n        .style(\"fill\", d => {\n            if (hasExpandableChildren(d.data.name)) return \"#0066cc\"; // Expandable nodes = blue\n            return \"#333\"; // Leaf nodes = dark gray\n        })\n        .style(\"cursor\", d => hasExpandableChildren(d.data.name) ? \"pointer\" : \"default\")\n        .text(d => d.data.name)\n        .on(\"click\", function(event, d) {\n            // Prevent zoom behavior when clicking on text\n            event.stopPropagation();\n\n            // Check persistent hierarchy instead of display node\n            const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n            if (persistentNode) {\n                if (persistentNode._children || persistentNode.children) {\n                    toggle(d);\n                }\n            }\n        })\n        .on(\"mouseover\", function(event, d) {\n            if (hasExpandableChildren(d.data.name)) {\n                d3.select(this).style(\"fill\", \"#0044aa\");\n            }\n        })\n        .on(\"mouseout\", function(event, d) {\n            d3.select(this).style(\"fill\", hasExpandableChildren(d.data.name) ? \"#0066cc\" : \"#333\");\n        });\n\n    // Add tooltips\n    nodes.append(\"title\")\n        .text(d => {\n            const effectiveSize = getEffectiveSize(d, d.data.name);\n            const originalSize = d.data.size || 0;\n\n            if (hasExpandableChildren(d.data.name)) {\n                const action = isCollapsed(d.data.name) ? \"expand\" : \"collapse\";\n                if (isCollapsed(d.data.name) && effectiveSize > originalSize) {\n                    return `${d.data.name} (Click to ${action}) - Aggregated size: ${effectiveSize} (own: ${originalSize})`;\n                } else {\n                    return `${d.data.name} (Click to ${action}) - Size: ${effectiveSize}`;\n                }\n            }\n            return `${d.data.name} - Size: ${effectiveSize}`;\n        });\n}\n\n// Initial render\nupdate();\n\n// Center on root after initial render\nsetTimeout(() => {\n    centerOnRoot();\n}, 100); // Small delay to ensure rendering is complete\n};","style":null,"version":6,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
</section>
<section id="spotify-metagenres" class="level2 page-columns page-full" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="spotify-metagenres"><span class="header-section-number">2.2</span> Spotify Metagenres</h2>
<details class="code-fold">
<summary>Show/Hide Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>s_gini_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="fig-spotify-gini" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-spotify-gini-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="03_metagenres_files/figure-html/gini_plot_spotify-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-spotify-gini-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the Spotify genre tree. Calculated for a minimum n tracks per genre of 1,000 to 4,980. Resulting number of metagenres ranged from 18 to 70.
</figcaption>
</figure>
</div>
<div class="column-screen-inset-right">
<div class="plot-container">
<div class="cell">
<details class="code-fold">
<summary>Show/Hide Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>s_long_metagenres <span class="ot">&lt;-</span> s <span class="sc">%&gt;%</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">left_join</span>(s_suggested_solution<span class="sc">$</span>mapping, <span class="at">by =</span> <span class="st">"tag_name"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>tag_name) <span class="sc">%&gt;%</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">rename</span>(<span class="at">tag_name =</span> metagenre)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot_network_graph</span>(<span class="at">graph =</span> s_suggested_solution<span class="sc">$</span>metagenre_graph, </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">get_sizes_lookup</span>(s_long_metagenres, <span class="at">root =</span> <span class="st">"POPULAR MUSIC"</span>),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                   <span class="fu">get_fills_lookup</span>(s_long_metagenres, <span class="at">root =</span> <span class="st">"POPULAR MUSIC"</span>),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                   <span class="at">height =</span> <span class="dv">1000</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="htmlwidget-e98a144e92970ac79b0e" style="width:100%;height:1000px;" class="r2d3 html-widget"></div>
<script type="application/json" data-for="htmlwidget-e98a144e92970ac79b0e">{"x":{"data":{"tree":{"name":"POPULAR MUSIC","size":1109.333333333333,"fill":"#808080ff","children":[{"name":"german hip hop","size":19678.03591512976,"fill":"#808080ff","children":[{"name":"german pop","size":10811.57646936397,"fill":"#808080ff","children":[{"name":"classic schlager","size":9294.25434010434,"fill":"#808080ff"},{"name":"german indie","size":3148.865476190476,"fill":"#808080ff"},{"name":"german rock","size":10516.03019480519,"fill":"#808080ff"},{"name":"schlager","size":6907.838564213564,"fill":"#808080ff"}]}]},{"name":"rock","size":18213.87210204828,"fill":"#808080ff","children":[{"name":"alternative metal","size":10417.4491998742,"fill":"#808080ff"},{"name":"alternative rock","size":3451.261429665106,"fill":"#808080ff","children":[{"name":"electronica","size":3162.311620732209,"fill":"#808080ff"}]},{"name":"classic rock","size":7600.12977388109,"fill":"#808080ff","children":[{"name":"blues rock","size":3219.747152847153,"fill":"#808080ff"}]},{"name":"hard rock","size":4181.652097902098,"fill":"#808080ff"},{"name":"metal","size":12016.20972540531,"fill":"#808080ff","children":[{"name":"german metal","size":5655.412987012987,"fill":"#808080ff"},{"name":"power metal","size":3458.420562770563,"fill":"#808080ff"}]},{"name":"modern rock","size":6476.023270830477,"fill":"#808080ff"},{"name":"new wave pop","size":10408.93061864606,"fill":"#808080ff"},{"name":"pop","size":14913.96788951523,"fill":"#808080ff","children":[{"name":"dance pop","size":11644.98809973998,"fill":"#808080ff"},{"name":"german techno","size":3334.052794112778,"fill":"#808080ff"},{"name":"hip hop","size":4298.399302755957,"fill":"#808080ff"},{"name":"rap","size":4051.592507705462,"fill":"#808080ff"}]},{"name":"singer-songwriter","size":8583.227960879276,"fill":"#808080ff"},{"name":"soft rock","size":7487.419207937745,"fill":"#808080ff","children":[{"name":"operatic pop","size":3386.997402597402,"fill":"#808080ff"}]}]}]},"weights":{"key":["alternative metal->rock","alternative rock->rock","blues rock->classic rock","classic rock->rock","classic schlager->german pop","dance pop->pop","electronica->alternative rock","german hip hop->POPULAR MUSIC","german indie->german pop","german metal->metal","german pop->german hip hop","german rock->german pop","german techno->pop","hard rock->rock","hip hop->pop","metal->rock","modern rock->rock","new wave pop->rock","operatic pop->soft rock","pop->rock","power metal->metal","rap->pop","rock->POPULAR MUSIC","schlager->german pop","singer-songwriter->rock","soft rock->rock"],"weight":[0.265110598420559,0.3995086689716452,0.3490471488085188,0.3768886273661379,0.0138694291453358,0.1777525471870477,0.04021541611302044,0,0.1020966628209923,0.222693764938617,0.008781545175598968,0.1470122247293045,0.009575113042160306,0.2656246067974438,0.02601968397163987,0.09314943747872367,0.3778976473062942,0.07020279920411393,0.133714197120807,0.02373813563934793,0.2464370121645713,0.04811521963177308,0,0.01981841720631153,0.2457135198545476,0.2252521109744465]},"margin_left":150,"margin_right":350,"margin_top":0,"margin_bottom":0,"min_font_size":22,"max_font_size":36},"type":"list","container":"svg","options":{"container":"div","viewer":null},"script":"var d3Script = function(d3, r2d3, data, svg, width, height, options, theme, console) {\nthis.d3 = d3;\n\nsvg = d3.select(svg.node());\n/* R2D3 Source File:  N:/Materialien/Promotion/GenreDiscourseAnalysis/inst/d3/interactive_network_plot.js */\n// Interactive Network Plot - Fully responsive dimensions\nconst minNodeSpacing = 30; // Minimum spacing between nodes to prevent overlap\n\n// Get responsive width from container with timing-safe approach\nconst getResponsiveWidth = () => {\n    // Try multiple ways to get the container width\n    const svgNode = svg.node();\n    const computedStyle = window.getComputedStyle(svgNode);\n    if (computedStyle.width && computedStyle.width !== \"auto\") {\n        const width = parseFloat(computedStyle.width);\n        if (width > 0) {\n            return width - 4;\n        }\n    }\n\n    // Fallback to viewport width\n    console.log(\"Using viewport fallback width\");\n    return window.innerWidth * 0.8;\n};\n\n// Use responsive dimensions - prioritize container dimensions over r2d3 data\nconst actualHeight = (data.height || 1000) - 4; // Reduce by 4px for borders/padding\nconst actualWidth = getResponsiveWidth();\n\n// Calculate dynamic height based on tree structure\nfunction calculateRequiredHeight(root) {\n    const visibleNodes = root.descendants();\n    const nodesByDepth = {};\n\n    // Group nodes by depth level\n    visibleNodes.forEach(node => {\n        const depth = node.depth;\n        if (!nodesByDepth[depth]) {\n            nodesByDepth[depth] = [];\n        }\n        nodesByDepth[depth].push(node);\n    });\n\n    // Find the depth level with the most nodes\n    const maxNodesAtLevel = Math.max(...Object.values(nodesByDepth).map(nodes => nodes.length));\n\n    // Calculate required height: nodes * spacing (no margins needed with pan/zoom)\n    const requiredHeight = Math.max(\n        600, // Minimum height\n        maxNodesAtLevel * minNodeSpacing\n    );\n\n    return requiredHeight;\n}\n\n// Initialize with container height, will be recalculated for tree layout\nlet currentHeight = actualHeight;\n\n// Set up the SVG to exactly match the container (no manual sizing)\nsvg.attr(\"width\", actualWidth)\n    .attr(\"height\", actualHeight)\n    .style(\"background-color\", \"#fafafa\")\n    .style(\"overflow\", \"hidden\") // Remove scrollbars\n    .style(\"cursor\", \"grab\")\n    .style(\"display\", \"block\");\n\n// Add resize handler for responsive width\nwindow.addEventListener(\"resize\", function() {\n    const newWidth = getResponsiveWidth();\n    svg.attr(\"width\", newWidth);\n\n    // If there\"s tree content, we might want to recalculate layout\n    // For now, just update the SVG width - the pan/zoom will handle positioning\n});\n\n// Add zoom behavior\nconst zoom = d3.zoom()\n    .scaleExtent([0.1, 3]) // Zoom limits\n    .on(\"zoom\", (event) => {\n        container.attr(\"transform\", event.transform);\n        // Update cursor during pan\n        svg.style(\"cursor\", event.sourceEvent && event.sourceEvent.type === \"mousemove\" ? \"grabbing\" : \"grab\");\n    });\n\nsvg.call(zoom);\n\n// Create container for tree (this will be transformed by zoom/pan)\nconst container = svg.append(\"g\")\n    .attr(\"class\", \"tree-container\");\n\n// Add center button\nconst centerButton = svg.append(\"g\")\n    .attr(\"class\", \"center-button\")\n    .attr(\"transform\", \"translate(20, 20)\")\n    .style(\"cursor\", \"pointer\");\n\n// Button background\ncenterButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#007acc\")\n    .style(\"stroke\", \"#005a9e\")\n    .style(\"stroke-width\", 1);\n\n// Button text\ncenterButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Center root\");\n\n// Button click handler\ncenterButton.on(\"click\", function() {\n    centerOnRoot();\n});\n\n// Add \"Expand All\" button\nconst expandAllButton = svg.append(\"g\")\n    .attr(\"class\", \"expand-all-button\")\n    .attr(\"transform\", \"translate(20, 60)\") // Position below center button\n    .style(\"cursor\", \"pointer\");\n\n// Expand All button background\nexpandAllButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#28a745\")\n    .style(\"stroke\", \"#1e7e34\")\n    .style(\"stroke-width\", 1);\n\n// Expand All button text\nexpandAllButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Expand All\");\n\n// Expand All button click handler\nexpandAllButton.on(\"click\", function() {\n    expandAll();\n});\n\n// Add \"Fold All\" button\nconst foldAllButton = svg.append(\"g\")\n    .attr(\"class\", \"fold-all-button\")\n    .attr(\"transform\", \"translate(20, 100)\") // Position below expand button\n    .style(\"cursor\", \"pointer\");\n\n// Fold All button background\nfoldAllButton.append(\"rect\")\n    .attr(\"width\", 100)\n    .attr(\"height\", 30)\n    .attr(\"rx\", 5)\n    .style(\"fill\", \"#dc3545\")\n    .style(\"stroke\", \"#c82333\")\n    .style(\"stroke-width\", 1);\n\n// Fold All button text\nfoldAllButton.append(\"text\")\n    .attr(\"x\", 50)\n    .attr(\"y\", 20)\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"dy\", \"0em\")\n    .style(\"fill\", \"white\")\n    .style(\"font-size\", \"12px\")\n    .style(\"font-weight\", \"bold\")\n    .style(\"pointer-events\", \"none\")\n    .text(\"Fold All\");\n\n// Fold All button click handler\nfoldAllButton.on(\"click\", function() {\n    foldAll();\n});\n\n// Function to center the view on the root node\nfunction centerOnRoot() {\n    if (!hierarchyRoot) return;\n\n    // Find the actual root node position after tree layout\n    const rootNode = hierarchyRoot;\n    const rootX = rootNode.x || 0;\n    const rootY = rootNode.y || 0;\n\n    // Calculate transform to center the root in the actual viewport\n    const centerX = actualWidth / 2;\n    const centerY = actualHeight / 2; // Center in actual viewport\n\n    const transform = d3.zoomIdentity\n        .translate(centerX - rootY, centerY - rootX) // Note: x and y are swapped in horizontal tree\n        .scale(1); // Reset zoom to 1x\n\n    // Animate to center\n    svg.transition()\n        .duration(750)\n        .call(zoom.transform, transform);\n} // Copy data and create persistent hierarchy\nlet currentData = JSON.parse(JSON.stringify(data.tree));\nlet hierarchyRoot = null; // Keep the hierarchy root persistent\nlet isFirstRender = true; // Track if this is the first render\n\n// Collapse function for raw data (not used anymore but keeping for reference)\nfunction collapseToFirstLevel(node, depth = 0) {\n    if (depth >= 1 && node.children) {\n        node._children = node.children;\n        node.children = null;\n    }\n    if (node.children) {\n        node.children.forEach(child => collapseToFirstLevel(child, depth + 1));\n    }\n}\n\n// Collapse function for D3 hierarchy nodes (the one we actually use)\nfunction collapseHierarchyToFirstLevel(node, depth = 0) {\n\n    if (depth >= 1 && node.children) {\n        node._children = node.children;\n        node.children = null;\n    }\n\n    // Continue recursively for visible children\n    if (node.children) {\n        node.children.forEach(child => collapseHierarchyToFirstLevel(child, depth + 1));\n    }\n\n    // Also process hidden children to ensure deep collapse\n    if (node._children) {\n        node._children.forEach(child => collapseHierarchyToFirstLevel(child, depth + 1));\n    }\n}\n\n// Sort children by accumulated size (largest first)\nfunction sortChildrenBySize(node) {\n    // Sort visible children\n    if (node.children) {\n        node.children.sort((a, b) => calculateTotalSize(b) - calculateTotalSize(a));\n        // Recursively sort their children too\n        node.children.forEach(child => sortChildrenBySize(child));\n    }\n\n    // Sort hidden children (so they\"re in the right order when expanded)\n    if (node._children) {\n        node._children.sort((a, b) => calculateTotalSize(b) - calculateTotalSize(a));\n        // Recursively sort their children too\n        node._children.forEach(child => sortChildrenBySize(child));\n    }\n}\n\n// Find a node in the hierarchy by name\nfunction findNodeByName(root, name) {\n    if (root.data.name === name) {\n        return root;\n    }\n    if (root.children) {\n        for (let child of root.children) {\n            const found = findNodeByName(child, name);\n            if (found) return found;\n        }\n    }\n    if (root._children) {\n        for (let child of root._children) {\n            const found = findNodeByName(child, name);\n            if (found) return found;\n        }\n    }\n    return null;\n}\n\n// Check if a node has expandable children in persistent hierarchy\nfunction hasExpandableChildren(nodeName) {\n    if (!nodeName || !hierarchyRoot) {\n        console.warn(\"hasExpandableChildren: Invalid parameters\", {\n            nodeName,\n            hierarchyRoot: !!hierarchyRoot\n        });\n        return false;\n    }\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n    return persistentNode && (persistentNode.children || persistentNode._children);\n}\n\n// Check if a node is collapsed in persistent hierarchy\nfunction isCollapsed(nodeName) {\n    if (!nodeName || !hierarchyRoot) {\n        console.warn(\"isCollapsed: Invalid parameters\", {\n            nodeName,\n            hierarchyRoot: !!hierarchyRoot\n        });\n        return false;\n    }\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n    return persistentNode && persistentNode._children && !persistentNode.children;\n}\n\n// Calculate the total size of a node including all its descendants\nfunction calculateTotalSize(node) {\n    let totalSize = node.data.size || 0;\n\n    // Add sizes from visible children\n    if (node.children) {\n        for (let child of node.children) {\n            totalSize += calculateTotalSize(child);\n        }\n    }\n\n    // Add sizes from hidden children (collapsed nodes)\n    if (node._children) {\n        for (let child of node._children) {\n            totalSize += calculateTotalSize(child);\n        }\n    }\n\n    return totalSize;\n}\n\n// Get the effective size for display (aggregated size for collapsed nodes)\nfunction getEffectiveSize(displayNode, nodeName) {\n    const persistentNode = findNodeByName(hierarchyRoot, nodeName);\n\n    if (persistentNode && isCollapsed(nodeName)) {\n        // For collapsed nodes, return the total aggregated size\n        return calculateTotalSize(persistentNode);\n    } else {\n        // For expanded nodes or leaf nodes, return their own size\n        return displayNode.data.size || 0;\n    }\n}\n\n// Toggle function\nfunction toggle(d) {\n    // Safety check for data structure\n    if (!d.data) {\n        console.error(\"Node data is undefined, skipping toggle\");\n        return;\n    }\n    // Find the corresponding node in our persistent hierarchy\n    const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n    if (!persistentNode) {\n        console.error(\"Could not find node in persistent hierarchy:\", d.data.name);\n        return;\n    }\n\n    if (persistentNode.children) {\n        persistentNode._children = persistentNode.children;\n        persistentNode.children = null;\n    } else if (persistentNode._children) {\n        persistentNode.children = persistentNode._children;\n        persistentNode._children = null;\n    }\n\n    // Re-sort the entire hierarchy to maintain size-based ordering\n    sortChildrenBySize(hierarchyRoot);\n\n    update();\n}\n\n// Expand All function\nfunction expandAll() {\n    if (!hierarchyRoot) return;\n\n    // Recursively expand all nodes\n    function expandAllNodes(node) {\n        if (node._children) {\n            node.children = node._children;\n            node._children = null;\n        }\n        if (node.children) {\n            node.children.forEach(child => expandAllNodes(child));\n        }\n    }\n\n    expandAllNodes(hierarchyRoot);\n    sortChildrenBySize(hierarchyRoot);\n    update();\n\n    // Center on root and zoom out 30%\n    setTimeout(() => {\n        if (!hierarchyRoot) return;\n\n        const rootNode = hierarchyRoot;\n        const rootX = rootNode.x || 0;\n        const rootY = rootNode.y || 0;\n\n        const centerX = actualWidth / 2;\n        const centerY = actualHeight / 2;\n\n        const transform = d3.zoomIdentity\n            .translate(centerX - rootY, centerY - rootX)\n            .scale(0.7); // Zoom out 30% (100% - 30% = 70%)\n\n        svg.transition()\n            .duration(750)\n            .call(zoom.transform, transform);\n    }, 100); // Small delay to let the tree update first\n}\n\n// Fold All function\nfunction foldAll() {\n    if (!hierarchyRoot) return;\n\n    // Collapse everything to root only (no children visible)\n    function collapseToRoot(node) {\n        if (node.children) {\n            node._children = node.children;\n            node.children = null;\n        }\n        if (node._children) {\n            node._children.forEach(child => collapseToRoot(child));\n        }\n    }\n\n    collapseToRoot(hierarchyRoot);\n    sortChildrenBySize(hierarchyRoot);\n    update();\n\n    // Center on root with normal zoom (same as center button)\n    setTimeout(() => {\n        centerOnRoot();\n    }, 100); // Small delay to let the tree update first\n}\n\n// Update function\nfunction update() {\n    // Clear previous content (but keep the center button)\n    container.selectAll(\"*\").remove();\n\n    // Create or use existing hierarchy\n    if (isFirstRender) {\n        hierarchyRoot = d3.hierarchy(currentData);\n        collapseHierarchyToFirstLevel(hierarchyRoot, 0);\n        // Sort all nodes by accumulated size after initial setup\n        sortChildrenBySize(hierarchyRoot);\n        isFirstRender = false;\n    }\n\n    const root = hierarchyRoot;\n\n    // Calculate required height dynamically for tree layout\n    currentHeight = calculateRequiredHeight(root);\n\n    // Set up tree layout with full available space (no margins)\n    const treeLayout = d3.tree().size([currentHeight, actualWidth]);\n    treeLayout(root);\n\n    // Position the tree centered in the actual viewport\n    const startX = 0; // No left margin needed\n    const startY = actualHeight / 2; // Center in actual viewport\n\n    // Adjust all node positions\n    root.descendants().forEach(d => {\n        d.x = d.x - currentHeight / 2 + startY; // Center in actual viewport\n        d.y = d.y + startX; // Start from left edge\n    });\n\n    // Scale for node sizes - now considering aggregated sizes for collapsed nodes\n    const allEffectiveSizes = root.descendants().map(d => getEffectiveSize(d, d.data.name));\n    const sizeScale = d3.scaleLinear()\n        .domain([0, d3.max(allEffectiveSizes) || 1])\n        .range([4, 15]);\n\n    // Convert weights data frame to lookup object\n    const weightsLookup = {};\n    if (data.weights && Array.isArray(data.weights.key)) {\n        // R data frame comes as arrays of columns\n        for (let i = 0; i < data.weights.key.length; i++) {\n            weightsLookup[data.weights.key[i]] = data.weights.weight[i];\n        }\n    }\n\n    // Function to get edge weight from lookup\n    function getEdgeWeight(link) {\n        if (Object.keys(weightsLookup).length === 0) {\n            return null;\n        }\n        // In your graph: edges go child->parent\n        // In D3 tree: link.target = child, link.source = parent\n        // So: target->source = child->parent\n        const key = link.target.data.name + \"->\" + link.source.data.name;\n        return weightsLookup[key] || null;\n    }\n    \n    // Create scales for edge styling based on weights\n    const allWeights = root.links()\n        .map(link => getEdgeWeight(link))\n        .filter(w => w !== null);\n    \n    let strokeWidthScale, strokeColorScale;\n    if (allWeights.length > 0) {\n        const minWeight = d3.min(allWeights);\n        const maxWeight = d3.max(allWeights);\n        \n        // Stroke width: thin (0.5) for small weights, thick (4) for large weights\n        strokeWidthScale = d3.scaleLinear()\n            .domain([minWeight, maxWeight])\n            .range([0.5, 4]);\n        \n        // Stroke color: light gray for small weights, black for large weights\n        strokeColorScale = d3.scaleLinear()\n            .domain([minWeight, maxWeight])\n            .range([\"#e0e0e0\", \"#000000\"]);\n    }\n\n    // Create links\n    const links = container.selectAll(\".link\")\n        .data(root.links())\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", \"link\")\n        .attr(\"d\", d3.linkHorizontal()\n            .x(d => d.y)\n            .y(d => d.x))\n        .style(\"fill\", \"none\")\n        .style(\"stroke\", d => {\n            const weight = getEdgeWeight(d);\n            return (weight !== null && strokeColorScale) ? strokeColorScale(weight) : \"#ccc\";\n        })\n        .style(\"stroke-width\", d => {\n            const weight = getEdgeWeight(d);\n            return (weight !== null && strokeWidthScale) ? strokeWidthScale(weight) : 2;\n        });\n\n    // Add tooltips to links\n    links.append(\"title\")\n        .text(d => {\n            const weight = getEdgeWeight(d);\n            if (weight !== null) {\n                return `${d.target.data.name} → ${d.source.data.name}\\nWeight: ${weight.toFixed(4)}`;\n            }\n            return `${d.target.data.name} → ${d.source.data.name}`;\n        });\n\n    // Create node groups\n    const nodes = container.selectAll(\".node\")\n        .data(root.descendants())\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"node\")\n        .attr(\"transform\", d => `translate(${d.y}, ${d.x})`)\n        .style(\"cursor\", d => (d.data && hasExpandableChildren(d.data.name)) ? \"pointer\" : \"default\");\n\n    // Add circles\n    nodes.append(\"circle\")\n        .attr(\"r\", d => sizeScale(getEffectiveSize(d, d.data.name)))\n        .style(\"fill\", d => d.data.fill || \"#69b3a2\")\n        .style(\"stroke\", d => (d.data && hasExpandableChildren(d.data.name)) ? \"#000\" : \"none\")\n        .style(\"stroke-width\", d => (d.data && hasExpandableChildren(d.data.name)) ? 2 : 1)\n        .on(\"click\", function(event, d) {\n            // Prevent zoom behavior when clicking on nodes\n            event.stopPropagation();\n\n            // Check persistent hierarchy instead of display node\n            const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n            if (persistentNode) {\n                if (persistentNode._children || persistentNode.children) {\n                    toggle(d);\n                }\n            }\n        })\n        .on(\"mouseover\", function(event, d) {\n            if (d.data && hasExpandableChildren(d.data.name)) {\n                d3.select(this).style(\"stroke-width\", 4);\n            }\n        })\n        .on(\"mouseout\", function(event, d) {\n            d3.select(this).style(\"stroke-width\", (d.data && hasExpandableChildren(d.data.name)) ? 2 : 1);\n        });\n\n    // Add +/- indicators\n    nodes.filter(d => d.data && hasExpandableChildren(d.data.name))\n        .append(\"text\")\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dy\", 4)\n        .style(\"font-size\", \"10px\")\n        .style(\"font-weight\", \"bold\")\n        .style(\"fill\", \"white\")\n        .style(\"pointer-events\", \"none\")\n        .text(d => isCollapsed(d.data.name) ? \"+\" : \"−\");\n\n    // Add labels\n    nodes.append(\"text\")\n        .attr(\"dy\", 3)\n        .attr(\"x\", d => hasExpandableChildren(d.data.name) ? -18 : 18)\n        .style(\"text-anchor\", d => hasExpandableChildren(d.data.name) ? \"end\" : \"start\")\n        .style(\"font-size\", \"12pt\")\n        .style(\"font-weight\", d => hasExpandableChildren(d.data.name) ? \"bold\" : \"normal\")\n        .style(\"text-decoration\", d => hasExpandableChildren(d.data.name) ? \"underline\" : \"none\")\n        .style(\"fill\", d => {\n            if (hasExpandableChildren(d.data.name)) return \"#0066cc\"; // Expandable nodes = blue\n            return \"#333\"; // Leaf nodes = dark gray\n        })\n        .style(\"cursor\", d => hasExpandableChildren(d.data.name) ? \"pointer\" : \"default\")\n        .text(d => d.data.name)\n        .on(\"click\", function(event, d) {\n            // Prevent zoom behavior when clicking on text\n            event.stopPropagation();\n\n            // Check persistent hierarchy instead of display node\n            const persistentNode = findNodeByName(hierarchyRoot, d.data.name);\n            if (persistentNode) {\n                if (persistentNode._children || persistentNode.children) {\n                    toggle(d);\n                }\n            }\n        })\n        .on(\"mouseover\", function(event, d) {\n            if (hasExpandableChildren(d.data.name)) {\n                d3.select(this).style(\"fill\", \"#0044aa\");\n            }\n        })\n        .on(\"mouseout\", function(event, d) {\n            d3.select(this).style(\"fill\", hasExpandableChildren(d.data.name) ? \"#0066cc\" : \"#333\");\n        });\n\n    // Add tooltips\n    nodes.append(\"title\")\n        .text(d => {\n            const effectiveSize = getEffectiveSize(d, d.data.name);\n            const originalSize = d.data.size || 0;\n\n            if (hasExpandableChildren(d.data.name)) {\n                const action = isCollapsed(d.data.name) ? \"expand\" : \"collapse\";\n                if (isCollapsed(d.data.name) && effectiveSize > originalSize) {\n                    return `${d.data.name} (Click to ${action}) - Aggregated size: ${effectiveSize} (own: ${originalSize})`;\n                } else {\n                    return `${d.data.name} (Click to ${action}) - Size: ${effectiveSize}`;\n                }\n            }\n            return `${d.data.name} - Size: ${effectiveSize}`;\n        });\n}\n\n// Initial render\nupdate();\n\n// Center on root after initial render\nsetTimeout(() => {\n    centerOnRoot();\n}, 100); // Small delay to ensure rendering is complete\n};","style":null,"version":6,"theme":{"default":{"background":"#FFFFFF","foreground":"#000000"},"runtime":null},"useShadow":true},"evals":[],"jsHooks":[]}</script>
</div>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>