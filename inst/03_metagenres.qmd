---
title: "Metagenres - Genre Discourse Analysis"
author: "Markus Radke"
date: "`r Sys.Date()`"
format: 
    html: 
        code-fold: true
        code-summary: "Show/Hide Code"
        output-dir: reports
        toc: true
        toc-location: left
        toc-depth: 5
        toc-expand: 5
        number-sections: true
        theme: cosmo
        code-links:
        - text: Github Repository
          href: "https://github.com/markusradke/GenreDiscourseAnalysis"
        css: |
          .plot-container {
            width: 100%;
            overflow: hidden;
            border: 1px solid #ddd;
            background-color: #fafafa;
            position: relative;
          }
          .r2d3 {
            overflow: hidden !important;
          }
          
          .r2d3 svg {
            overflow: hidden !important;
          }
          
          .r2d3 > div {
            overflow: hidden !important;
          }
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
devtools::load_all()
```	

# Algorithm for folding the genre tree to get metagenres
<!-- TODO: Add a little explanation on the algorithm (see Bayreuth slides) -->

```{mermaid folding_algorithm}
flowchart TD
    A["Start with initial music genres and hierarchy tree"] --> B["Try different minimum song counts (grid search)"]
    B --> C["For each minimum count: Start folding process"]
    C --> D["Find leaf genre with most songs at deepest level"]
    D --> E{"Does this genre have enough songs?"}
    E -->|Yes| F{"Would parent + siblings have enough songs combined?"}
    E -->|No| G["Merge genre with parent and all siblings"]
    F -->|Yes| H["Remove genre from tree (fold upward)"]
    F -->|No| G
    G --> I["Update song counts and mark genres as processed"]
    H --> I
    I --> J{"Are we at the root level?"}
    J -->|No| D
    J -->|Yes| K["Calculate diversity score (Gini coefficient)"]
    K --> L{"Can we calculate a valid diversity score?"}
    L -->|Yes| M["Save this solution and try next minimum count"]
    L -->|No| N["Stop search - no more valid solutions"]
    M --> O{"More minimum counts to try?"}
    O -->|Yes| C
    O -->|No| P["Remove duplicate solutions and return best options"]
    N --> P
    P --> Q["End: Return optimized genre groupings"]
```	

# Tuning results and suggested solutions
```{r read_results}
mb_tuning_metadata <- readRDS("../models/metagenres/tune_mb_metadata.rds")
mb_gini_plot <- readRDS("../models/metagenres/tune_mb_gini_plot.rds")
mb_suggested_solution <- readRDS("../models/metagenres/metagenres_mb_suggested_solution.rds")

dc_gini_plot <- readRDS("../models/metagenres/tune_dc_gini_plot.rds")
dc_tuning_metadata <- readRDS("../models/metagenres/tune_dc_metadata.rds")
dc_suggested_solution <- readRDS("../models/metagenres/metagenres_dc_suggested_solution.rds")

s_tuning_metadata <- readRDS("../models/metagenres/tune_s_metadata.rds")
s_gini_plot <- readRDS("../models/metagenres/tune_s_gini_plot.rds")
s_suggested_solution <- readRDS("../models/metagenres/metagenres_s_suggested_solution.rds")
```

## MusicBrainz Metagenres
:::{#fig-musicbrainz-gini}
```{r gini_plot_musicbrainz}
mb_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the MusicBrainz genre tree. Calculated for a minimum n tracks per genre of `r format(mb_tuning_metadata$min_min_n, big.mark = ",")` to `r format(mb_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r mb_tuning_metadata$min_n_metagenre` to `r mb_tuning_metadata$max_n_metagenre`.
:::



## Discogs Metagenres
:::{#fig-discogs-gini}
```{r gini_plot_discogs}
dc_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the Discogs genre tree. Calculated for a minimum n tracks per genre of `r format(dc_tuning_metadata$min_min_n, big.mark = ",")` to `r format(dc_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r dc_tuning_metadata$min_n_metagenre` to `r dc_tuning_metadata$max_n_metagenre`.
:::


## Spotify Metagenres
:::{#fig-spotify-gini}
```{r gini_plot_spotify}
s_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the Spotify genre tree. Calculated for a minimum n tracks per genre of `r format(s_tuning_metadata$min_min_n, big.mark = ",")` to `r format(s_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r s_tuning_metadata$min_n_metagenre` to `r s_tuning_metadata$max_n_metagenre`.
:::

:::{.column-screen-inset-right}
:::{.plot-container}
```{r network_plot_spotify}
plot_network_graph(graph = s_suggested_solution$metagenre_graph, 
                   mapping = s_suggested_solution$mapping, 
                   sizemode = "metagenre", 
                   height = 1000, 
                   interactive = TRUE)
```	
:::
:::