---
title: "Metagenres - Genre Discourse Analysis"
author: "Markus Radke"
date: "`r Sys.Date()`"
format: 
    html: 
        code-fold: true
        code-summary: "Show/Hide Code"
        output-dir: reports
        toc: true
        toc-location: left
        toc-depth: 5
        toc-expand: 5
        number-sections: true
        theme: cosmo
        code-links:
        - text: Github Repository
          href: "https://github.com/markusradke/GenreDiscourseAnalysis"
        css: 
          styles.css
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
devtools::load_all()
```	

# Algorithm for folding the genre tree to get metagenres
<!-- TODO: Add a little explanation on the algorithm (see Bayreuth slides) -->
Root of the tree is "other" genre. This is why it does not need to fulfill the minimum song count requirement. 

We need to ensure that when merging genres, we merge all siblings and all grandchildren of the parent genre to avoid dangling nodes in the tree. Due to how the trees are created, merging grand children that already fulfilled the min n requirement will not occur often (genres that are closer to the root are expected to appear more frequent in initial genres than genres further away from the root).

<!-- Eigentlich müsste es sogar so sein, das,,s der bei unterschreiten der Pfad mit der kleineren Summe eingeklappt wird, oder? Leider sind die Merging-Regeln noch kompliziertere nämlich: 
Im Prinzip ist die Frage: Wie umgehen mit schwach besetzten Genres in der nähe von Root, wenn Genres in die detailierter sind, zahlreicher vertreten sind? 
Problemfall: Ich habe ein starkes Genre, das zum Metagenre wird. Das Elterngenre ist aber schwach besetzt und müsste nach Algorithmus eingeklappt werden. 
Aktuelle Lösung: dann inklusive des als Metagenre dedachten Genres einklappen, weil sonst der Baum nicht konsistent ist oder die min n Forderung nicht erfüllt ist. 
-->

The algorithm works as follows:
```{mermaid folding_algorithm}
%%{init: {
  'flowchart': {
    'nodeSpacing': 50, 
    'rankSpacing': 80,
    'useMaxWidth': true,
    'htmlLabels': false,
    'curve': 'basis'
  }, 
  'theme': 'base',
  'themeVariables': {
    'fontSize': '22px',
    'fontFamily': 'Arial, sans-serif',
    'primaryColor': '#ffffff',
    'primaryTextColor': '#333333',
    'primaryBorderColor': '#cccccc', 
    'lineColor': '#666666',
    'textColor': '#333333'
  }
}}%%
flowchart TD
    A["Start with initial music genres and hierarchy tree"] --> B["Try different minimum song counts (grid search)"]
    B --> C["For each minimum count: Start folding process"]
    C --> D["Find leaf genre with most songs at deepest level"]
    D --> E{"Does this genre have enough songs?"}
    E -->|Yes| F{"Is the parent genre the root of the tree?"}
    E -->|No| G["Merge genre with parent and all siblings and all grandchildren of parent that were already metagenres"]
    F -->|No| FF{"Would parent + siblings have enough songs combined?"}
    FF --> |Yes| H["Pluck genre from tree (cut connection to parent)"]
    FF -->|No| G
    F -->|Yes| H
    G --> I["Update song counts and mark genres as processed"]
    H --> I
    I --> J{"Are we at the root level?"}
    J -->|No| D
    J -->|Yes| K["Calculate diversity score (Gini coefficient)"]
    K --> L{"Can we calculate a valid diversity score?"}
    L -->|Yes| M["Save this solution and try next minimum count"]
    L -->|No| N["Stop search - no more valid solutions"]
    M --> O{"More minimum counts to try?"}
    O -->|Yes| C
    O -->|No| P["Remove duplicate solutions and return best options"]
    N --> P
    P --> Q["End: Return optimized genre groupings"]
```	

# Tuning results and suggested solutions
```{r read_results}
mb_tuning_metadata <- readRDS("../models/metagenres/tune_mb_metadata.rds")
mb_gini_plot <- readRDS("../models/metagenres/tune_mb_gini_plot.rds")
mb_suggested_solution <- readRDS("../models/metagenres/metagenres_mb_suggested_solution.rds")

s_tuning_metadata <- readRDS("../models/metagenres/tune_s_metadata.rds")
s_gini_plot <- readRDS("../models/metagenres/tune_s_gini_plot.rds")
s_suggested_solution <- readRDS("../models/metagenres/metagenres_s_suggested_solution.rds")
```

## MusicBrainz Metagenres
:::{#fig-musicbrainz-gini}
```{r gini_plot_musicbrainz}
mb_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the MusicBrainz genre tree. Calculated for a minimum n tracks per genre of `r format(mb_tuning_metadata$min_min_n, big.mark = ",")` to `r format(mb_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r mb_tuning_metadata$min_n_metagenre` to `r mb_tuning_metadata$max_n_metagenre`.
:::

:::{.column-screen-inset-right}
:::{.plot-container}
```{r network_plot_mb}
plot_network_graph(graph = mb_suggested_solution$metagenre_graph, 
                   mapping = mb_suggested_solution$mapping, 
                   sizemode = "metagenre", 
                   height = 1000, 
                   interactive = TRUE)
```	
:::
:::

## Spotify Metagenres
:::{#fig-spotify-gini}
```{r gini_plot_spotify}
s_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the Spotify genre tree. Calculated for a minimum n tracks per genre of `r format(s_tuning_metadata$min_min_n, big.mark = ",")` to `r format(s_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r s_tuning_metadata$min_n_metagenre` to `r s_tuning_metadata$max_n_metagenre`.
:::

:::{.column-screen-inset-right}
:::{.plot-container}
```{r network_plot_spotify}
plot_network_graph(graph = s_suggested_solution$metagenre_graph, 
                   mapping = s_suggested_solution$mapping, 
                   sizemode = "metagenre", 
                   height = 1000, 
                   interactive = TRUE)
```	
:::
:::