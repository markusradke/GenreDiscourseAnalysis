---
title: "Metagenres - Genre Discourse Analysis"
author: "Markus Radke"
date: "`r Sys.Date()`"
format: 
    html: 
        code-fold: true
        code-summary: "Show/Hide Code"
        output-dir: reports
        toc: true
        toc-location: left
        toc-depth: 5
        toc-expand: 5
        number-sections: true
        theme: cosmo
        code-links:
        - text: Github Repository
          href: "https://github.com/markusradke/GenreDiscourseAnalysis"
        css: 
          styles.css
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
devtools::load_all()
```	

# Algorithm for folding the genre tree to get metagenres
<!-- TODO: Add a little explanation on the algorithm (see Bayreuth slides) -->
Root of the tree is "other" genre. This is why it does not need to fulfill the minimum song count requirement. 

We need to ensure that when merging genres, we merge all siblings and all grandchildren of the parent genre to avoid dangling nodes in the tree. Due to how the trees are created, merging grand children that already fulfilled the min n requirement will not occur often (genres that are closer to the root are expected to appear more frequent in initial genres than genres further away from the root).


The algorithm works as follows:
```{mermaid folding_algorithm}
%%{init: {
  'flowchart': {
    'nodeSpacing': 50, 
    'rankSpacing': 80,
    'useMaxWidth': true,
    'htmlLabels': false,
    'curve': 'basis'
  }, 
  'theme': 'base',
  'themeVariables': {
    'fontSize': '22px',
    'fontFamily': 'Arial, sans-serif',
    'primaryColor': '#ffffff',
    'primaryTextColor': '#333333',
    'primaryBorderColor': '#cccccc', 
    'lineColor': '#666666',
    'textColor': '#333333'
  }
}}%%
flowchart TD
    A["Start with initial music genres and hierarchy tree"] --> B["Try different minimum song counts (grid search)"]
    B --> C["For each minimum count: Start folding process"]
    C --> D["Find leaf genre with most songs at deepest level"]
    D --> E{"Does this genre have enough songs?"}
    E -->|Yes| F{"Is the parent genre the root of the tree?"}
    E -->|No| G["Merge genre with parent and all siblings and all grandchildren of parent that were already metagenres"]
    F -->|No| FF{"Would parent + siblings have enough songs combined?"}
    FF --> |Yes| H["Pluck genre from tree (cut connection to parent)"]
    FF -->|No| G
    F -->|Yes| H
    G --> I["Update song counts and mark genres as processed"]
    H --> I
    I --> J{"Are we at the root level?"}
    J -->|No| D
    J -->|Yes| K["Calculate diversity score (Gini coefficient)"]
    K --> L{"Can we calculate a valid diversity score?"}
    L -->|Yes| M["Save this solution and try next minimum count"]
    L -->|No| N["Stop search - no more valid solutions"]
    M --> O{"More minimum counts to try?"}
    O -->|Yes| C
    O -->|No| P["Remove duplicate solutions and return best options"]
    N --> P
    P --> Q["End: Return optimized genre groupings"]
```	

# Tuning results and suggested solutions
```{r read_results}
mb <- read_feather_with_lists("../data/filtered_mb_long.feather")
mb_tuning_metadata <- readRDS("../models/metagenres/tune_mb_metadata.rds")
mb_gini_plot <- readRDS("../models/metagenres/tune_mb_gini_plot.rds")
mb_suggested_solution <- readRDS("../models/metagenres/metagenres_mb_suggested_solution.rds")

s <- read_feather_with_lists("../data/filtered_s_long.feather")
s_tuning_metadata <- readRDS("../models/metagenres/tune_s_metadata.rds")
s_gini_plot <- readRDS("../models/metagenres/tune_s_gini_plot.rds")
s_suggested_solution <- readRDS("../models/metagenres/metagenres_s_suggested_solution.rds")
```

## MusicBrainz Metagenres
:::{#fig-musicbrainz-gini}
```{r gini_plot_musicbrainz}
mb_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the MusicBrainz genre tree. Calculated for a minimum n tracks per genre of `r format(mb_tuning_metadata$min_min_n, big.mark = ",")` to `r format(mb_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r mb_tuning_metadata$min_n_metagenre` to `r mb_tuning_metadata$max_n_metagenre`.
:::

:::{.column-screen-inset-right}
:::{.plot-container}
```{r network_plot_mb}
mb_long_metagenres <- mb %>%
  dplyr::left_join(mb_suggested_solution$mapping, by = "tag_name") %>%
  dplyr::select(-tag_name) %>%
  dplyr::rename(tag_name = metagenre)

plot_network_graph(graph = mb_suggested_solution$metagenre_graph, 
                   get_sizes_lookup(mb_long_metagenres, root = "POPULAR MUSIC"),
                   get_fills_lookup(mb_long_metagenres, root = "POPULAR MUSIC"),
                   height = 1000)
```	
:::
:::

## Spotify Metagenres
:::{#fig-spotify-gini}
```{r gini_plot_spotify}
s_gini_plot
```
Within-hierarchy-level uniformity of distribution (weighted Gini coefficient, [0-1]) for different minimum song per genre counts when folding the Spotify genre tree. Calculated for a minimum n tracks per genre of `r format(s_tuning_metadata$min_min_n, big.mark = ",")` to `r format(s_tuning_metadata$max_min_n, big.mark = ",")`. Resulting number of metagenres ranged from `r s_tuning_metadata$min_n_metagenre` to `r s_tuning_metadata$max_n_metagenre`.
:::

:::{.column-screen-inset-right}
:::{.plot-container}
```{r network_plot_spotify}
s_long_metagenres <- s %>%
  dplyr::left_join(s_suggested_solution$mapping, by = "tag_name") %>%
  dplyr::select(-tag_name) %>%
  dplyr::rename(tag_name = metagenre)
plot_network_graph(graph = s_suggested_solution$metagenre_graph, 
                   get_sizes_lookup(s_long_metagenres, root = "POPULAR MUSIC"),
                   get_fills_lookup(s_long_metagenres, root = "POPULAR MUSIC"),
                   height = 1000)
```	
:::
:::